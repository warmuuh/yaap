Note: as of the v6 codegen, this walkthrough is obsolete, as it documents the v5 (recursive, non-streaming) parsers.

Line-by-line explanation of a generated parser for the arithmetic grammar.

function p_arith_Expr(str){
 var tbl=[],pos=0,l=str.length+1;while(l--)tbl.push([]);l=str.length;
 function Expr(a){var x,p=pos,c;if(x=tbl[p][0]){pos=x[1];a.push([p,0]);return 1}if(x==false){return 0}c=[];return fin(c,p,0,_Expr(c),a)}

Each rule takes an `a` argument which is an array, and pushes a result onto it if the parse succeeds.
This array is the child node set of the parent node in the parse tree.
The result is the position at which the match begins, followed by the rule index, here 0.
if(x=tbl[p][0]) means that the cached result at this position was a success, all we need to do is note this as a child node in the parent.
The length of the match already exists in the result table.
if(x==false) means that the cached result was a failed match, we simply return false in that case.
Otherwise the result is not cached (x will have been undefined) and we need to test it, which we do by calling fin with our own child array, the position, the rule index, the result of calling the test function for the rule, and the parent's child array as arguments.

 function Add(a){var x,p=pos,c;if(x=tbl[p][1]){pos=x[1];a.push([p,1]);return 1}if(x==false){return 0}c=[];return fin(c,p,1,_Add(c),a)}
 function Mult(a){var x,p=pos,c;if(x=tbl[p][2]){pos=x[1];a.push([p,2]);return 1}if(x==false){return 0}c=[];return fin(c,p,2,_Mult(c),a)}
 function Num(a){var x,p=pos,c;if(x=tbl[p][3]){pos=x[1];a.push([p,3]);return 1}if(x==false){return 0}c=[];return fin(c,p,3,_Num(c),a)}
 function S(a){var x,p=pos,c;if(x=tbl[p][4]){pos=x[1];a.push([p,4]);return 1}if(x==false){return 0}c=[];return fin(c,p,4,_S(c),a)}
 var _Expr=Add
 var _Add=q(Mult,r(0,0,q(r(0,1,S),sl_0,r(0,1,S),Mult)))
 var _Mult=q(Num,r(0,0,q(r(0,1,S),sl_1,r(0,1,S),Num)))
 var _Num=o(sl_2,q(cs_0,r(0,0,cs_1)))
 var _S=r(1,0,cs_2)
 function cs_0(){var c,x;if(pos==l)return false;c=g(pos);x=c<49?0:c<58?1:0;if(x){pos++;return true}return false}

Charset test functions test the current character for membership in a cset.
The JavaScript expression that does this (here "c<49?0:c<58?1:0;") is generated by the cset library.
The function returns true or false and advances the current position if it returns true.

 function cs_1(){var c,x;if(pos==l)return false;c=g(pos);x=c<48?0:c<58?1:0;if(x){pos++;return true}return false}
 function cs_2(){var c,x;if(pos==l)return false;c=g(pos);x=c<32?0:c<33?1:0;if(x){pos++;return true}return false}
 function sl_0(){var p=pos;if(str.charCodeAt(p)==43){pos+=1;return true}return false}

String literal test functions are similar.

 function sl_1(){var p=pos;if(str.charCodeAt(p)==42){pos+=1;return true}return false}
 function sl_2(){var p=pos;if(str.charCodeAt(p)==48){pos+=1;return true}return false}
 function fin(c,p,x,r,a){if(r)a.push([p,x]);tbl[p][x]=r?[true,pos,c]:false;return r}

fin() is called from the rule entry functions above.
Arguments are a Child array, start Position at which to test, rule indeX, test Result, parent Array.
If the result is true we push the start position and index onto the parent array.
We record the result in the result table as tbl[p][x].
The result table is indexed first by position in the string, then by rule index.
An entry in the table is either [true,<position at end of match>,children], or it is false.

 function e(){return true}

e() matches the empty string.
It does this by consuming no input (i.e. not incrementing pos) and by returning true.
We need a function for this because the parser combinators below are defined over functions.

Next we have the combinators, in order these functions are: Ordered choice, seQuence, Repetition, Negative and Positive lookahead.

 function o(){var args=arguments;return function(c){var i,l;for(i=0,l=args.length;i<l;i++)if(args[i](c))return true;return false}}
 function q(){var args=arguments;return function(c){var i,l,cp=pos,cl=c.length;for(i=0,l=args.length;i<l;i++)if(!args[i](c)){pos=cp;t(c,cl);return false}return true}}
 function r(m,n,f){return function(c){var i=0,cp=pos,cl=c.length;while(i<m){i++;if(!f(c)){pos=cp;t(c,cl);return false}}cl=c.length;while(i++<n||n==0)if(!f(c))return true;return true}}
 function n(f){return function(){var p=pos,x=f([]);pos=p;return !x}}
 function p(f){return function(){var p=pos,x=f([]);pos=p;return x}}
 function t(a,n){if(a.length&gt;n)a.splice(n)}

t() truncates an array in place efficiently.

 function g(p){return str.charCodeAt(p)}

g() gets the current character.
This needs to be updated to handle UTF-16.
All uses of str.charCodeAt() should then be replaced with it, and then it should probably be inlined everywhere it is used.
What we probably want to do is use charCodeAt(), do the test against the expression generated from the BMP part of the cset, and then if that fails call the function that tests if the character is outside the BMP, consumes the next character if so, generates the actual codepoint, and then tests against the non-BMP subset of the cset.

 function b(p,n){var x=tbl[p][n],c=[],a=[n,x[1]-p,c],y=x[2],i=0,l=y.length,z;for(;i<l;i++){z=y[i];if(z[0]&gt;p)c.push([-1,z[0]-p]);c.push(b(z[0],z[1]));p=tbl[z[0]][z[1]][1]}if(p<x[1]&&c.count)c.push([-1,x[1]-p]);return a}

b() builds the parse tree which is returned.
It uses the result table to find the children of each node recursively and add them to an array which it returns.
The parse tree result representation as nested arrays is described in doc/parse_tree_representation.

 return Expr([])&&pos==l?[true,b(0,0)]:[false,pos,tbl]}

When called, the function calls the start rule function with an empty child array as argument.
If this returns true the position is tested against string length to see if the entire string was matched.
If both of these are true then the result parse tree is built and [true,<parse tree>] is returned.
Otherwise [false,pos,tbl] is returned.

p_arith_streaming_Expr.names=['Expr','Add','Mult','Num','S'];

Finally the rule names are attached to the parser function so that the human-readable names can be looked up (e.g. by showTree) when interpreting the parse tree.