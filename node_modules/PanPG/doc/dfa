notes on deterministic finite automata

A DFA is a 5-tuple (Q, Σ, δ, q₀, F)

Q is a set of states,
Σ is the alphabet,
δ is the transition function Q × Σ → Q,
q₀ is the start state, and
F is the set of accepting states (F ⊆ Q)

We wish to opportunistically construct a set of DFAs matching a regular part of a PEG when it is likely to improve the efficiency of the parser.

The function v6_dfa and related functions construct DFAs which matches a given regular expression.

The states are implicit, each DFA represents a state and points to zero or more other states.
The alphabet is the set of UTF-16 code points and is the same for every DFA we construct.
The transition function from each state is a list of (cset, DFA) pairs.
The first cset in the array which matches the input gives the next state.
If none of the csets in the array match the next input character, then the DFA fails to match the input.
This is a more efficient representation than constructing a 65536-element array for each state.
From this representation, state transition code in the target language can be generated, making whatever tradeoffs are chosen between space and speed.

The states we generate as intermediate values may include lookahead assertions and as such are slightly more than a true DFA.
They may also represent ordered choice expressions with higher-priority alternatives that may fail after a lower priority alternative has succeeded.
Both of these cases introduce backtracking.
While a DFA simply consumes an input and ends in either an accepting or rejecting state, the parsers we are interested in constructing also record the end position of the match, and combined with ordered choice and lookahead assertions, this requires a limited kind of backtracking.
The objects we construct are thus not true DFAs but are DFA-like objects, or DLOs.
In many cases, the DLOs will be combined such that the lookahead of an earlier expression can be combined with an expression which follows to give a pure DFA that does not require lookahead.

To construct a DFA for a single cset, we simply return `{transition:[cset,success]}`.

For seq(a,b):
First construct the DFAs d1 and d2 for a and b respectively.
In the transitive closure of d1, replace 'match' states with d2.
This must be done without mutating the original states, since they may be pointed to from existing states.
return d1

For OrdChoice(a,b):

d2 = dfa(b)
d1 = dfa(a)

start with d1 and d2 states.

This will be implemented by character range, but we describe it by character for simplicity:
For each symbol in the alphabet:
  Collect the state from d1 and d2 which that character will match.
  If they are both fail states, do nothing.
  If they are both match states, add a transition to the match state.
  Otherwise, compare the states to each other and to as many already-created states as desired.
  For each, if an equivalent state is found in the object we are constructing, extend the transition to that state to include this symbol.
  If an equivalent state is found elsewhere, add a transition pointing to it.

When an input character would result in both d1 and d2 transitioning to new, distinct states, we must create a new state which will combine the states to which they would move.

This is not entirely obvious, because the d1 state must have priority, if it succeeds, even if d2 reaches a success state while the outcome of d1 is still unknown.
So this is a case that introduces backtracking.
We can introduce a new kind of special state value which will cause the runtime to push the position at which d2 matches onto a stack.
Then if d1 fails, the expression will succeed anyway, and the position will be the position at which d2 succeeded.

Ah... this isn't exactly a stack, it's more like a set of possible slots that can be filled with either success (and an end position) or failure.
The parser then runs until the top (highest priority) slot is filled, and if it failed, runs until the next slot is filled, and so on until either a slot succeeds (with all slots above failing) or every slot fails.

The success states themselves (as different accepting states) contain enough information to determine the priority of the match when it succeeds.
Since each new state created in a merge between the two existing DFAs already implies the priority information, then we only need one additional state value to store the end position, and each state transition in which one of the set of alternatives succeeds can either replace the stored end position with the current position, if the alternative that just matched had a higher priority than any that matched previously, or leave it as is otherwise.

So in the DLO, we have a map of accepting states to priorities.
To merge two DLOs which both have multiple accepting priorities, we simply lower the priorities in the second set so that they do not overlap with those from the first.
In every match state we have a match priority as an integer.
To update the second DLO while merging, these integers must be increased (higher values being lower priority...).
So the final DLO contains a set of match states which are annotated with a priority.
When generating byte code, machine code, or JavaScript code, these match state annotations can be turned into operations that update the end position that is stored.
If the DLO is interpreted directly, an array could be used.

So when combining two:
If the character means that either could still succeed, carry on as normal
if the character means that a has succeeded, regardless of whether (lower-priority) b can succeed, accept.
If the character means that b has succeeded, but a could still succeed, then in this case only, we need to store the position, and, in any future state at which b fails, instead succeed but do it at the stored position.

This means in the latter case we have a state that can do some backtracking.
If this is combined with another DFA c in a sequence, then...
We want to end up with a state where, if a accepts, we transition into c, or if b accepts.
Then if c accepts, after getting there from a state in a, ...ok.
It's as if we are appending c onto both a and b in the original ordered choice expression.
So "(a / b) c" becomes "(a c / b c)".
This means that all thet states in `c` are duplicated, instead of just having a pointer to `c` from both `a` and `b`, so this should be avoided except when necessary.
So when merging `c` into `(a / b)`, we look at all the match states in `a / b`, which will have a priority, either 0 if it came from `a` or 1 if from `b`.
This gives new `c` states that are 'tagged' by their priority, and in these merged `c` instances, the accept states inherit these priorities.
So the result of a sequence where the first DLO has this end-saving property is just another such DLO, there is still no need to do any backtracking.
It does make it impossible to merge the occurrences of the `c` states however.
This could be obviated by managing the priority explicitly at runtime, using something like an array, where the end position of the result would come from looking at the array...
however even in this case, the `c` instances would need to push their results to different array positions.
so the real way to eliminate this would have to actually use a stack, so that the same instance of `c` could take different priorities depending on the state of the machine at the point where the `c` state was entered/called.

So we have a property of transition states which is that they can store the current position while transitioning to the new state.
And a property of match states which is that they can use the stored position instead of the current position.
This will never result in backtracking within the DFA, as this property is folded into the DFA as it is constructed, but can result in backtracking one time at the end when the DFA matches.

For rep(a):

Construct the dfa for a.
All repetitions in a PEG are greedy, so if a repetition subexpression succeeds it will always be tried again; it does not introduce a branch.
So, walk the DFA for a, and for every occurrence of the match state, replace it with a pointer to a itself.
For every fail state, replace it with a success state.
(Note that if there are implicit catch-all fail states at the end of the DFA, we need to replace these.)
(Alternatively, we could have a "default", "fallthrough" or "catchall" property that specifies a state to move to when no specified cset matches the input.)

For neg(a) or pos(a):

A lookahead in a sequence must run to completion before the result of the sequence is known.
We are not only interested in whether the sequence succeeds, but also in the length of the match, i.e. the position at which the expression succeeds.
Lookaheads have a backtracking semantics, i.e. the lookahead may consume any amount of input, but only the non-lookahead expressions advance the position.
In some sequences of the form seq(lookahead(a), b) the lookahead can be folded into b, yeilding a DFA that matches the sequence without tracking any additional data about lookahead state.
This can be done whenever it can be proved that any match of b will reach a fail or match state against a before or at the same time as reaching a match state in b.
In other words, if by the time we reach a terminal state in b, we have already got an answer about the match status of a, then there is no need for any backtracking, and a dfa can represent the expression.

A lookahead at the end of a sequence is an obvious case where the lookahead cannot be folded into any subsequent expression.
In many grammars, such lookaheads correspond to features that make the language LL(k) and are limited to looking ahead some fixed number of tokens, but a PEG does not enforce any such limitation.
This is a case where, when substituting a rule body, which ends with a lookahead, into a sequence, a DFA can be created, even though the rule itself cannot be expressed as a DFA.
For example, in the ES5 grammar, the rules for tokens such as IfTok look like: "if" !IdentifierPart, i.e, a string literal followed by a negative lookahead (corresponding to a character class).
In any case where this token will be used, it will be followed by some whitespace or other token anyway, and this next input character needs to be something that could not be part of an identifier for the token to end.
So if the IfTok rule is substituted into the IfStatement (or some other) rule, that rule, or some part of it, could be matched by a DFA.

This is taken care of currently for our needs because we only generate DFAs for selected rules anyway, and we flatten any references in the expression before attempting to do so.

However, we still have to deal with "lookahead-ness" bubbling up out of sub-expressions.

So in the case of any lookahead that can't trivially be flattened into a subsequent expression, we will simply bail out and not generate any DFA at all for that rule.

To do the flattening, for a rule of the form seq(pos(a),b):

Generate DFAs for a and b.
For each character σ in Σ:
Find δ_a(σ) and δ_b(σ).
If δ_a(σ) is the failure state, then let δ(σ) be the failure state as well.
If δ_b(σ) is a terminal state (match or fail), but δ_a(σ) is not, then decline to return a DFA for this expression.
Instead, return a dfa object with an additional "lookahead" property which contains δ_a(σ), marked as a positive lookahead.
While this object is not a proper DFA, if it is used by the parent as part of a sequence, that sequence may turn into a DFA again.

For a rule of the form seq(neg(a),b):

The rules are similar to the above, but with the success and failure states of δ_a reversed.

If the rule for seq() deals with DFA-like objects that have lookahead-ness correctly, we can just define a rule for neg() and pos(), and deal with the lookahead flattening in the seq() case.

So, in summary:

----------
the values
----------

We create and manipulate values which represent a DFA-like objects, or DLOs.
A DLO does not correspond exactly to a DFA, since it may contain backtracking states and lookaheads.

A DLO is either a match state, a fail state, or a transition state (one in which the parse result is not yet known) which includes transitions from each input character to a new state.
A DLO corresponds to a PEG expression, and is sufficient to determine both the match or failure of the expression as well as the end position in case of a match.
Transition states may have a hanging_match array, and a hanging_fail array, and match states may have a hanging_index property; these are used to handle backtracking expressions as described below.
Intermediate results that include backtracking and lookahead, when combined in a sequence, will not necessarily result in a combined DLO that uses backtracking or lookahead: often the backtracking or lookahead states will be folded into the later part of the sequence, resulting in a true DFA that does not require backtracking or use a stack.

In the implementation, every DLO is a JavaScript object having the following properties:
- type (either "match", "fail", or "transition"),
- positive and negative, which are optional Booleans,
- hanging_match and hanging_fail, which are arrays of integers used for hanging match states,
- hanging_index, which is an integer, optionally set on match states
- transition, which is an array of cset, DLO pairs,
- eof, which is a DLO for the EOF transition

If the type is "transition", the transition and eof properties define the transition function from characters or the EOF state to a new state.
Otherwise the transition and eof properties are ignored.
The transition table may not cover every character in the alphabet, in which case the unmatched characters transition to a fail state by default.
A positive or negative DLO is equivalent to a qualified match state: it is a match if a match or fail state (respectively) is eventually reached, but the match does not include the lookahead.
A hanging match represents the end position of a match which may succeed or fail, either because of a lookahead or because it is dominated by a previous ordered choice branch, the outcome of which is still indeterminate.
When a hanging match is reached during parsing the parser must record the position.
When a hanging_fail array is encountered, the indices given in the array, each of which must refer to a previous hanging match, have retroactively failed.
At a match state, if the hanging_index is set, the end position after the match is the position at which the hanging match with that index was reached.

Once a hanging_match state is reached, it must be impossible to reach a hard fail state.
Actually, that is only true in the case of dominated matches, not lookaheads.

-------------
the algorithm
-------------

First the expression is rewritten to use only cset, sequence, ordered choice, positive and negative lookahead.
Named references, string literals, and ε are rewritten or substituted as necessary.

For cset:
return {type:"transition"
       ,transition:[<the cset>,{type:"match"}]}

For sequence:
If the sequence is empty, return {type:"match"}
Let d1 be the DLO for the first element of the sequence, and let d2 be the DLO for the remainder of the sequence.
If d1 is a match state, the result is d2.
If d1 is a fail state, the result is a fail state.
If d1 is a transition state, the result depends on d2.
If d2 is a match state, the result is d1.
If d2 is a fail state, the result is a fail state.
Otherwise both are transition states.
If d1 is a hanging match, then merge d1 and d2, replacing corresponding hanging fail states in d1 with fail states, fail states in d1 or d2 with fail states, match states in d1 having hanging indices with the transition state from d2, and 

For ordered choice:
If the ordered choice is empty, return {type:"fail"}
Let d1 be the DLO for the first alternative, and d2 the DLO for the remainder of the ordered choice.
If d1 or d2 is a fail state, the result is d2 or d1 respectively.
If d1 is a match state, d1 is the result.
If d1 is a hanging state, d1 is the result[1], and a warning may be emitted.
If d1 is a lookahead, the result is a hanging state, with the transition calculated by negating[2] d1 and lookahead-merging it with d2[3].
Otherwise, d1 is a transition state.
If d2 is a match state, the result is a hanging state with the d1 transition.
If d2 is a hanging state, the result is a hanging state[4], and the transition is an ordered-choice transition merge (defined below) of the d1 and d2 transitions.
If d2 is a lookahead, this leads to a conditional hanging state in which d2 creates a hanging match, but that match can be canceled in the future by the lookahead.[5]

[1] If d1 is a hanging state, it will always match, and d2 will never be tried.
[2] To negate here means to replace a positive or negative lookahead with the other.
[3] This uses the equality of `&a / b` with `!a b / &a` to potentially merge !a into b, removing lookahead.
[4] The transition must allow fallback to the current position if d1 and the dominating d2 alternative fail.
    If the dominating d2 alternative succeeds while d1 is indeterminate, then the new position replaces the fallback position of the previous hanging result.
    So ordered choice does not introduce cases where multiple hanging results need to be stored at once.
    At each point, there may already be a hanging choice, but even if so, any new hanging choice that can be created must at a higher priority and can replace the old stored position.
[5] Since a hanging match can be canceled, this means that multiple hanging results do need to be stored.
    It is possible for a higher priority hanging match to be canceled, and then a lower-priority hanging match may be used.
    S ← A / B &C / D
    If D matches first, then B matches, then C fails, and finally A fails, then the D match is the result.
    This means D needs to create a hanging match, and B needs to push a hanging match onto a stack.
    Then C and the remainder of A can be tested in parallel until a result is attained.
    When the negative result of C is known, the B match needs to be canceled.
    It is also possible for a result to be canceled that would not be at the top of a stack:
    S ← A / B &C / D &E
    In this case, if D and then B succeed, and then E fails while C (and A) are still indeterminate, then the hanging match for D must be canceled, even though the most recent hanging match is B.
    Therefore, lookaheads with ordered choice can introduce a system of hanging matches, where, if the DLO is interpreted, multiple hanging matches can be added, and then subsequently canceled, until a final outcome is known.
    The depth of this structure of hanging results is finite and determined by the grammar, regardless of the input string.
    The DLO implementation could encode which hanging result to use in the final success state, or it can defer the decision to runtime, possibly resulting in a smaller number of states.

------------
simpler case
------------

In the case where no hanging states are allowed, and negative and positive lookahead are not allowed, the algorithm can be much simpler.
In the more complex cases we may simply decline to generate a DFA.

We have then an expression containing only ordered choice, sequence, and cset expressions.

A motivating example is the CodePoint rule from PEG.peg, and its two dependencies:

CodePoint         ← UPlusCodePoint
                  / CodePointLit

UPlusCodePoint    ← "U+" HEXDIG{4,6}

CodePointLit      ← [ [:^Zs:] − U+005D − U+2212 ]

In this case the input "U" could be either a CodePointLit or the beginning of a UPlusCodePoint, so this creates a hanging success which will succeed if UPlusCodePoint fails.

In the case of a cset, return {type:'transition',transition:[[<cset>,{type:'match'}]]}

In the case of a sequence, if the sequence is empty, return {type:'match'}.
Otherwise, generate DLOs d1 and d2 for the first element and remainder of the sequence, respectively.
Walk d1, substituting d2 for any match state.

In the case of an ordered choice, if it is empty, return {type:'fail'}.
Otherwise, let d1 and d2 be the DLO for the first element and remainder of the ordered choice, respectively.
If d1 is a fail state, return d2.
If d2 is a fail state, return d1.
If d1 is a match state, return d1.
If d2 is a match state, decline.
Construct an NFA from d1 and d2 as follows:

For each character σ in the input alphabet

-----------------
even simpler case
-----------------

In the PEG grammar, a CharEscape is a backslash followed by 4 hex digits or one of the C backslash escape characters.

CharEscape        ← [U+005C] HEXDIG{4,4}
                  / [U+005C] [ f n r t v ]

HEXDIG            ← [0-9A-F]

This generates the following two DLOs, for the two branches of the ordered choice:

     {ordc_d1:{type:'transition'
              ,transition:[[[92,93]
                           ,{type:'transition'
                            ,transition:[[[48,58,65,71]
                                         ,{type:'transition'
                                          ,transition:[[[48,58,65,71]
                                                       ,{type:'transition'
                                                        ,transition:[[[48,58,65,71]
                                                                     ,{
                                                                      type:'transition'
                                                                      ,transition:[[[48
                                                                                    ,58
                                                                                    ,65
                                                                                    ,71]
                                                                                   ,{
                                                                                    type:'match'}]]}]]}]]}]]}]]}}
     
     {ordc_d2:{type:'transition'
              ,transition:[[[92,93]
                           ,{type:'transition'
                            ,transition:[[[102,103,110,111,114,115,116,117,118,119]
                                         ,{type:'match'}]]}]]}}

In both cases there is a transition on "\", and then transitions on either a hex digit or one of "f n r t v", which is disjoint with the hex digits (since lowercase 'a-f' does not appear there, otherwise the f would be a collision).
Since the first transition is the same, we can merge the two, by a left-factoring transformation:

α β / α γ  →  α ( β / γ )

Since the subsequent transitions are disjoint, there is no need to deal with any hanging or dominated match states, and the transition after "\" can simply succeed if one of "f n r t v" is seen, and continue on if 0-9A-F is seen.

To merge the two equal and the two unequal transitions, we use a function which iterates two transitions after the manner of a truth-table, creating a new character range for each range which leads to a different state in one or the other of the two transitions, and returns the list of character ranges, and the results from each transition.
For the d1 and d2 transitions shown above this gives:

     [[[0,92],{type:'fail'},{type:'fail'}]
     ,[[92,93],{type:'transition'
               ,transition:[[[48,58,65,71]
                            ,{type:'transition'
                             ,transition:[[[48,58,65,71]
                                          ,{type:'transition'
                                           ,transition:[[[48,58,65,71]
                                                        ,{type:'transition'
                                                         ,transition:[[[48,58,65,71]
                                                                      ,{type:'match'}]]}]]}]]}]]}
              ,{type:'transition'
               ,transition:[[[102,103,110,111,114,115,116,117,118,119],{type:'match'}]]}]
     ,[[93],{type:'fail'},{type:'fail'}]]

This can then be processed further to get back to a DLO.

,dfa:{type:'transition'
     ,transition:[[[92,93]
                  ,{type:'transition'
                   ,transition:[[[48,58,65,71]
                                ,{type:'transition'
                                 ,transition:[[[48,58,65,71]
                                              ,{type:'transition'
                                               ,transition:[[[48,58,65,71]
                                                            ,{type:'transition'
                                                             ,transition:[[[48,58,65,71]
                                                                          ,{type:'match'}]]}]]}]]}]
                               ,[[102,103,110,111,114,115,116,117,118,119]
                                ,{type:'match'}]]}]]}

---------------
code generation
---------------

Once a DFA is constructed, it can be interpreted or compiled into JavaScript.

The DFA above can be compiled into the following code:

if(s[pos]=='\')
 if(hex(s[++pos])){
  if(hex(s[++pos])&&hex(s[++pos])&&hex(s[++pos])) return true}
 else if(cs0(s[pos]))return true
return false

with (char → Boolean) helper functions hex and cs0 for the 0-9a-f and [fnrtv] character classes.

The if-else construct is problematic: since we have a DFA we should try to find the next state in a single step rather than examine the character repeatedly.

function s1(c){return c=='\'?s2(s[++pos]):false}
function s2(c){if(

We have two csets that lead to non-failure states, these are, in binary:

0000000000110000  48
..                ..
0000000000111001  57

0000000001000001  65
..                ..
0000000001000110  70

-> hex transition

102, 110, 114, 116, 118 -> match

0000000001100110  102
0000000001101110  110
0000000001110010  114
0000000001110100  116
0000000001110110  118

Since in this case all are fairly low ASCII-range characters, we can filter first with a bitmask.
In this case, each of the lowest 7 bits is set in at least one value, so this is equivalent to a > operation.
To know whether this is a good first step or not, we would need to have character frequency data for this state collected by an instrumented parser on a representative sample.

Once anything > 127 has been excluded, we have seven bits left to look at.
Instead of a bitmask, a >118 operation would probably be about as efficient.
Then < 48.
Then > 70, and if < 70, two more operations can exclude the 57-65 range.
If > 70, then the next test should be < 102, and then at most three more comparison operations can make a determination.

Alternatively, we could store a value which encodes the result, which is one of three states, for each of the 127 possible values of the last 7 bits.
This requires 127 * 2 = 254 bits 

Reading Russ Cox's dfa.cc I encountered a great idea used there, which is to create a map of all character ranges that are treated differently by any part of the DFA, and then map each character onto a smaller integer, which is then used in the lookup.
This could be done with full 16-bit characters, or with characters lower than some limit.

In this case we have [\], [ftnrv], [0-9A-Z], and all others, for a total of four classes.
So an idea here is to have a single function which takes a character (and could maybe even handle UTF-16 decoding also) and returns an integer from a reduced set.
This function could actually be shared by an entire parser, which would put all the character classes computation in one place and reduce code size quite a bit.
The maximum size of this integer depends on how many distint character classes there are in the entire grammar that are handled differently.
In the case of the ECMAScript grammar, this would include all the characters used in tokens and keywords such as "function", all punctuation used in operators or control structures, etc, but it would collapse all of the large Unicode character classes such as letters, digits, etc, into single values since these are all handled as a class and never used individually.
Probably this would be fewer than 127 distinct values for the entire grammar, meaning that states wouldn't be that huge and could use a call to the reduction function followed by a single array lookup to find the next state for each character.

Next: benchmarks.

Chrome 5.0.375.55 beta:

nested ifs:
ops/ms: 6669 ms: 4000 max: 38 min: 0 n: 26051
checksum: 756
array of int:
ops/ms: 7071 ms: 4000 max: 10 min: 0 n: 27620
checksum: 756
string:
ops/ms: 5616 ms: 4000 max: 6 min: 0 n: 21937
checksum: 756
crazy switch:
ops/ms: 1667 ms: 4000 max: 8 min: 0 n: 6510
checksum: 756

Firefox 3.5.9:

nested ifs:
ops/ms: 213.9 ms: 4003 max: 21 min: 3 n: 836
checksum: 460
array of int:
ops/ms: 221.4 ms: 4001 max: 15 min: 3 n: 865
checksum: 460
string:
ops/ms: 138.4 ms: 4002 max: 1378 min: 4 n: 541
checksum: 460
crazy switch:
ops/ms: 248.4 ms: 4003 max: 14 min: 3 n: 971
checksum: 460

The > 1000ms max on the string benchmark is repeatable, it is probably causing Firefox to do some garbage collection or allocation there.
Firefox seems to like the crazy switch approach, but I don't and it bloats the code (unless the switch is generated at runtime with eval), and Chrome hates it (even though Chrome's worst is much faster than Firefox's best).
The string is suboptimal in Firefox, but not as much as I would have expected actually.
The array does well in both, and the nested ifs are close.
The nested ifs are less straightforward to generate than the array, but for the entire UTF-16 range the array may be much larger, and these numbers may change.

Trying an array with the entire UTF-16 range in it (that is, a 65536-element array of small ints) and using the Ll Unicode category (lower-case letters) as a test, this adds the "ridiculous array" benchmark:

Firefox:

nested ifs:
ops/ms: 150.9 ms: 4417 max: 1531 min: 3 n: 651
checksum: 460
array of int:
ops/ms: 233.4 ms: 4001 max: 21 min: 3 n: 912
checksum: 460
crazy switch:
ops/ms: 127.7 ms: 4000 max: 1927 min: 3 n: 499
checksum: 460
ridiculous array:
ops/ms: 253.4 ms: 4001 max: 13 min: 3 n: 990
checksum: 1168

The checksum is different because this is not implementing the same map as the other tests, but this should not affect the speed.

Chrome:

nested ifs:
ops/ms: 6460 ms: 4000 max: 7 min: 0 n: 25234
checksum: 756
array of int:
ops/ms: 7138 ms: 4000 max: 6 min: 0 n: 27884
checksum: 756
crazy switch:
ops/ms: 1640 ms: 4000 max: 8 min: 0 n: 6407
checksum: 756
ridiculous array:
ops/ms: 7458 ms: 4000 max: 11 min: 0 n: 29131
checksum: 1648

Both Chrome and Firefox prefer the ridiculous array, and it's easy to implement, so that is the solution I am going to use.
It's interesting that the lookup in the 64k array is faster than a single inequality test followed by a lookup into a < 200 array.
Actually, what am I saying... this is not interesting but perfectly obvious, as the test input doesn't include any non-ASCII characters, so the reasonable-sized array is always doing the array lookup anyway.
The difference between the two is just the cost of the > comparison op, which never weeds out any of the code points in the sample so is just a cost.
The performance would be different on a sample including many high code point values.

The ridiculous array does increase the size of the parser by at least 128 KB, that is, at least a small integer and a comma for each of the 65536 values.
Some of the integers will take two or more digits depending on the grammar.
For a smaller parser, the array can be constructed at runtime.
Actually, instead of including the csets and full code to construct the array, a simple RLE compressed version of the array would probably be just as compact.

One benefit of the ridiculous array approach is that the lookup can be directly inlined, there is no need for a lookup function since inlining the array lookup won't increase the code size, since there is no 'if' guard or anything else before the array lookup.

## ridiculous array construction

We construct this array by considering every cset which appears in the grammar.
Each character is mapped to an equivalence class, and these equivalence classes are then used in place of characters themselves in state transitions.
First we collect all the csets and assign a numeric ID to each one.
We can also use a canonical serialization of the cset as a hash key to find duplicate csets.
Then we look at each character in the UTF-16 range, and for each, determine which csets it participates in.
This can be as simple as constructing an array of csets-ids for each character in the 65536.
Then we assign an ID to each equivalence class, and assign one of these IDs to every character.
This is done character by character, by looking at the equivalence classes which have already had IDs assigned to them, and if this is a new one, assigning a new integer to it.
Two characters are equivalent if the set of csets which includes them is the same.
As we do this, we also record, for each cset, a set of the equivalence classes which comprise it.
In the generated code, this mapping from equivalence classes to csets is what will be used to determine whether the cset matched, after the character has been matched to an equivalence class.

## DFA to JavaScript

Once the DFA is constructed, it needs to be integrated into the packrat parser.
I will write the first implementation by hand in the existing PEG parser for the CharEscape rule used above:

CharEscape        ← [U+005C] HEXDIG{4,4}
                  / [U+005C] [ f n r t v ]

HEXDIG            ← [0-9A-F]

Some of the data generated by the code so far:

{equiv_class_:{id:0,key:'equiv_class_',member_cset_ids:[]}
,equiv_class_1:{id:1,key:'equiv_class_1',member_cset_ids:[1]}
,equiv_class_0:{id:2,key:'equiv_class_0',member_cset_ids:[0]}
,equiv_class_2:{id:3,key:'equiv_class_2',member_cset_ids:[2]}}
[{key:'cset_92,93',cset:[92,93],equivs:[2],id:0}
,{key:'cset_48,58,65,71',cset:[48,58,65,71],equivs:[1],id:1}
,{key:'cset_102,103,110,111,114,115,116,117,118,119'
 ,cset:[102,103,110,111,114,115,116,117,118,119],equivs:[3],id:2}]
{cset_92,93:{key:'cset_92,93',cset:[92,93],equivs:[2],id:0}
,cset_48,58,65,71:{key:'cset_48,58,65,71',cset:[48,58,65,71],equivs:[1],id:1}
,cset_102,103,110,111,114,115,116,117,118,119:{key:'cset_102,103,110,111,114,115,116,117,118,119'
                                              ,equivs:[3],id:2
                                              ,cset:[102,103,110,111,114,115,116
                                                    ,117,118,119]}}

CharEscape ← (CharEscape+0 seq (CharEscape+1 ordC (CharEscape+2 seq (CharEscape+3 cset 5c) (CharEscape+4 seq (CharEscape+5 ref HEXDIG) (CharEscape+6 ref HEXDIG) (CharEscape+7 ref HEXDIG) (CharEscape+8 ref HEXDIG) (CharEscape+9 ϵ))) (CharEscape+10 seq (CharEscape+11 cset 5c) (CharEscape+12 cset 66 6e 72 74 76))))

{S:20,name:'CharEscape',direct_deps:['HEXDIG','HEXDIG','HEXDIG','HEXDIG']
,known_regular:[true]
,all_csets:[[92,93],[48,58,65,71],[92,93]
           ,[102,103,110,111,114,115,116,117,118,119]]
,re:[2
    ,[[3
      ,[[2,[[0,[92,93]],[4,4,4,[5,'HEXDIG']]]]
       ,[2,[[0,[92,93]],[0,[102,103,110,111,114,115,116,117,118,119]]]]]]]]
,dfa:{type:'transition'
     ,transition:[[[92,93]
                  ,{type:'transition'
                   ,transition:[[[48,58,65,71]
                                ,{type:'transition'
                                 ,transition:[[[48,58,65,71]
                                              ,{type:'transition'
                                               ,transition:[[[48,58,65,71]
                                                            ,{type:'transition'
                                                             ,transition:[[[48,58
                                                                           ,65
                                                                           ,71]
                                                                          ,{type:'match'}]]}]]}]]}]
                               ,[[102,103,110,111,114,115,116,117,118,119]
                                ,{type:'match'}]]}]]}
,expr:{id:'CharEscape+0',type:2,S:20,T:1179648,M:324,F:325,toplevel:true
      ,flag_n:2735,anon_consume:false,can_emit_named:true,S_flags:84655
      ,S_flags_:'10100101010101111'
      ,flags:{cache:true,t_bufferout:true,pushpos:true,t_emitstate:true
             ,m_emitstate:false,m_emitclose:true,m_emitanon:false
             ,m_emitlength:true,m_resetpos:false,m_emitbuf:true,m_tossbuf:false
             ,f_tossbuf:true}
      ,subexprs:[ ...

So, the start state here for CharEscape+0 is 84655, or 20 after the flag bits are shifted off.
This is the S value we would expect to find in the parser when it is about to test the CharEscape rule against the input.

With a tracing parser, parsing the input 'S ← "\n"', the following lines, among others, are produced:

First we have a positive result, in which the StrLit rule hands off to the CharEscape at position 5, which then accepts the "\n" escape sequence, and returns a true result after advancing to position 7.

main          S:StrLit+4 pos:5 \ R:undefined stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284 posns:0,0,0,4,4,4,4,4,4,4,4,4 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27] buf:22
main          S:CharEscape+0 pos:5 \ R:undefined stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284,285 posns:0,0,0,4,4,4,4,4,4,4,4,4 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27] buf:22
main          S:CharEscape+1 pos:5 \ R:undefined stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284,285,20 posns:0,0,0,4,4,4,4,4,4,4,4,4,5 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27],[22] buf:20
main          S:CharEscape+2 pos:5 \ R:undefined stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284,285,20,288 posns:0,0,0,4,4,4,4,4,4,4,4,4,5 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27],[22] buf:20
main          S:CharEscape+3 pos:5 \ R:undefined stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284,285,20,288,289 posns:0,0,0,4,4,4,4,4,4,4,4,4,5,5 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27],[22],[20] buf:
result        S:CharEscape+3 pos:6 n R:1 stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284,285,20,288,289 posns:0,0,0,4,4,4,4,4,4,4,4,4,5,5,5 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27],[22],[20] buf:
res_end       S:CharEscape+4 pos:6 n R:undefined stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284,285,20,288,289 posns:0,0,0,4,4,4,4,4,4,4,4,4,5,5 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27],[22],[20] buf:-1,1
main          S:CharEscape+4 pos:6 n R:undefined stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284,285,20,288,289 posns:0,0,0,4,4,4,4,4,4,4,4,4,5,5 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27],[22],[20] buf:-1,1
main          S:CharEscape+5 pos:6 n R:undefined stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284,285,20,288,289,291 posns:0,0,0,4,4,4,4,4,4,4,4,4,5,5,6 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27],[22],[20],[-1,1] buf:
main          S:HEXDIG+0 pos:6 n R:undefined stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284,285,20,288,289,291,292 posns:0,0,0,4,4,4,4,4,4,4,4,4,5,5,6 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27],[22],[20],[-1,1] buf:
main          S:HEXDIG+1 pos:6 n R:undefined stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284,285,20,288,289,291,292,18 posns:0,0,0,4,4,4,4,4,4,4,4,4,5,5,6,6 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27],[22],[20],[-1,1],[] buf:18
result        S:HEXDIG+1 pos:6 n R:0 stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284,285,20,288,289,291,292,18 posns:0,0,0,4,4,4,4,4,4,4,4,4,5,5,6,6 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27],[22],[20],[-1,1],[] buf:18
res_end       S:HEXDIG+0 pos:6 n R:false stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284,285,20,288,289,291,292 posns:0,0,0,4,4,4,4,4,4,4,4,4,5,5,6,6 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27],[22],[20],[-1,1],[] buf:18
result        S:HEXDIG+0 pos:6 n R:false stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284,285,20,288,289,291,292 posns:0,0,0,4,4,4,4,4,4,4,4,4,5,5,6,6 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27],[22],[20],[-1,1],[] buf:18
res_end       S:CharEscape+5 pos:6 n R:false stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284,285,20,288,289,291 posns:0,0,0,4,4,4,4,4,4,4,4,4,5,5,6 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27],[22],[20],[-1,1] buf:
result        S:CharEscape+5 pos:6 n R:false stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284,285,20,288,289,291 posns:0,0,0,4,4,4,4,4,4,4,4,4,5,5,6 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27],[22],[20],[-1,1] buf:
res_end       S:CharEscape+4 pos:6 n R:false stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284,285,20,288,289 posns:0,0,0,4,4,4,4,4,4,4,4,4,5,5,6 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27],[22],[20],[-1,1] buf:
result        S:CharEscape+4 pos:6 n R:false stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284,285,20,288,289 posns:0,0,0,4,4,4,4,4,4,4,4,4,5,5,6 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27],[22],[20],[-1,1] buf:
res_end       S:CharEscape+2 pos:6 n R:false stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284,285,20,288 posns:0,0,0,4,4,4,4,4,4,4,4,4,5,5 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27],[22],[20] buf:-1,1
result        S:CharEscape+2 pos:6 n R:false stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284,285,20,288 posns:0,0,0,4,4,4,4,4,4,4,4,4,5,5 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27],[22],[20] buf:-1,1
res_end       S:CharEscape+10 pos:5 \ R:undefined stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284,285,20,288 posns:0,0,0,4,4,4,4,4,4,4,4,4,5 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27],[22] buf:20
main          S:CharEscape+10 pos:5 \ R:undefined stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284,285,20,288 posns:0,0,0,4,4,4,4,4,4,4,4,4,5 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27],[22] buf:20
main          S:CharEscape+11 pos:5 \ R:undefined stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284,285,20,288,297 posns:0,0,0,4,4,4,4,4,4,4,4,4,5,5 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27],[22],[20] buf:
result        S:CharEscape+11 pos:6 n R:1 stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284,285,20,288,297 posns:0,0,0,4,4,4,4,4,4,4,4,4,5,5 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27],[22],[20] buf:
res_end       S:CharEscape+12 pos:6 n R:undefined stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284,285,20,288,297 posns:0,0,0,4,4,4,4,4,4,4,4,4,5,5 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27],[22],[20] buf:
main          S:CharEscape+12 pos:6 n R:undefined stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284,285,20,288,297 posns:0,0,0,4,4,4,4,4,4,4,4,4,5,5 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27],[22],[20] buf:
result        S:CharEscape+12 pos:7 " R:1 stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284,285,20,288,297 posns:0,0,0,4,4,4,4,4,4,4,4,4,5,5 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27],[22],[20] buf:
res_end       S:CharEscape+10 pos:7 " R:true stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284,285,20,288 posns:0,0,0,4,4,4,4,4,4,4,4,4,5,5 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27],[22],[20] buf:
result        S:CharEscape+10 pos:7 " R:true stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284,285,20,288 posns:0,0,0,4,4,4,4,4,4,4,4,4,5,5 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27],[22],[20] buf:
res_end       S:CharEscape+1 pos:7 " R:true stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284,285,20 posns:0,0,0,4,4,4,4,4,4,4,4,4,5 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27],[22] buf:20,-1,2
result        S:CharEscape+1 pos:7 " R:true stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284,285,20 posns:0,0,0,4,4,4,4,4,4,4,4,4,5 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27],[22] buf:20,-1,2
res_end       S:CharEscape+0 pos:7 " R:true stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284,285 posns:0,0,0,4,4,4,4,4,4,4,4,4,5 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27],[22] buf:20,-1,2
result        S:CharEscape+0 pos:7 " R:true stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284,285 posns:0,0,0,4,4,4,4,4,4,4,4,4,5 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27],[22] buf:20,-1,2
res_end       S:StrLit+4 pos:7 " R:true stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284 posns:0,0,0,4,4,4,4,4,4,4,4,4 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27] buf:22,20,-1,2,-2,2
result        S:StrLit+4 pos:7 " R:true stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284 posns:0,0,0,4,4,4,4,4,4,4,4,4 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27] buf:22,20,-1,2,-2,2



There is a lot going on in the above trace, just to consume two characters.
We wish to replace this with a DFA which has the same effect on the parser state, so that StrLit will still work just the same.

The first and last few lines should show the relevant changes in the machine state that must be preserved:

main          S:StrLit+4 pos:5 \ R:undefined stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284 posns:0,0,0,4,4,4,4,4,4,4,4,4 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27] buf:22
main          S:CharEscape+0 pos:5 \ R:undefined stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284,285 posns:0,0,0,4,4,4,4,4,4,4,4,4 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27] buf:22
main          S:CharEscape+1 pos:5 \ R:undefined stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284,285,20 posns:0,0,0,4,4,4,4,4,4,4,4,4,5 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27],[22] buf:20
 ...
result        S:CharEscape+1 pos:7 " R:true stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284,285,20 posns:0,0,0,4,4,4,4,4,4,4,4,4,5 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27],[22] buf:20,-1,2
res_end       S:CharEscape+0 pos:7 " R:true stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284,285 posns:0,0,0,4,4,4,4,4,4,4,4,4,5 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27],[22] buf:20,-1,2
result        S:CharEscape+0 pos:7 " R:true stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284,285 posns:0,0,0,4,4,4,4,4,4,4,4,4,5 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27],[22] buf:20,-1,2
res_end       S:StrLit+4 pos:7 " R:true stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284 posns:0,0,0,4,4,4,4,4,4,4,4,4 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27] buf:22,20,-1,2,-2,2

Between the start and end of the CharEscape rule application:
The stack is unchanged.
The position is advanced by two.
The position stack is unchanged.
The buffer stack is unchanged.
The current buffer has been extended by the success of the 20 rule, with an anonymous node of length 2, which is co-extensive with the 20 node itself.
In our case, the CharEscape rule has been defined to be a leaf rule, which means it will not have any children, including any anonymous nodes, so the only change to the buffer will be the "20,-2,2" for the CharEscape itself and its length.
So the only change in state is that the buffer is extended and the position is advanced.
The change to the buffer can happen at the end, and requires the start position to be stored to calculate the node length.
The start position can be stored in a local variable rather than pushed onto a stack, since DFA calls will never be nested.

The result is signalled to the caller by the R variable, which is true when the StrLit+4 state is re-entered.


In the second case, still at position 7, the StrLit again hands off to CharEscape, which fails, since the closing quote of the string literal has been reached:

main          S:StrLit+4 pos:7 " R:undefined stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284 posns:0,0,0,4,4,4,4,4,4,4,4,4 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27] buf:22,20,-1,2,-2,2
main          S:CharEscape+0 pos:7 " R:undefined stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284,285 posns:0,0,0,4,4,4,4,4,4,4,4,4 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27] buf:22,20,-1,2,-2,2
main          S:CharEscape+1 pos:7 " R:undefined stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284,285,20 posns:0,0,0,4,4,4,4,4,4,4,4,4,7 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27],[22,20,-1,2,-2,2] buf:20
main          S:CharEscape+2 pos:7 " R:undefined stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284,285,20,288 posns:0,0,0,4,4,4,4,4,4,4,4,4,7 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27],[22,20,-1,2,-2,2] buf:20
main          S:CharEscape+3 pos:7 " R:undefined stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284,285,20,288,289 posns:0,0,0,4,4,4,4,4,4,4,4,4,7,7 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27],[22,20,-1,2,-2,2],[20] buf:
result        S:CharEscape+3 pos:7 " R:0 stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284,285,20,288,289 posns:0,0,0,4,4,4,4,4,4,4,4,4,7,7,7 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27],[22,20,-1,2,-2,2],[20] buf:
res_end       S:CharEscape+2 pos:7 " R:false stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284,285,20,288 posns:0,0,0,4,4,4,4,4,4,4,4,4,7,7 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27],[22,20,-1,2,-2,2],[20] buf:
result        S:CharEscape+2 pos:7 " R:false stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284,285,20,288 posns:0,0,0,4,4,4,4,4,4,4,4,4,7,7 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27],[22,20,-1,2,-2,2],[20] buf:
res_end       S:CharEscape+10 pos:7 " R:undefined stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284,285,20,288 posns:0,0,0,4,4,4,4,4,4,4,4,4,7 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27],[22,20,-1,2,-2,2] buf:20
main          S:CharEscape+10 pos:7 " R:undefined stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284,285,20,288 posns:0,0,0,4,4,4,4,4,4,4,4,4,7 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27],[22,20,-1,2,-2,2] buf:20
main          S:CharEscape+11 pos:7 " R:undefined stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284,285,20,288,297 posns:0,0,0,4,4,4,4,4,4,4,4,4,7,7 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27],[22,20,-1,2,-2,2],[20] buf:
result        S:CharEscape+11 pos:7 " R:0 stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284,285,20,288,297 posns:0,0,0,4,4,4,4,4,4,4,4,4,7,7 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27],[22,20,-1,2,-2,2],[20] buf:
res_end       S:CharEscape+10 pos:7 " R:false stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284,285,20,288 posns:0,0,0,4,4,4,4,4,4,4,4,4,7,7 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27],[22,20,-1,2,-2,2],[20] buf:
result        S:CharEscape+10 pos:7 " R:false stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284,285,20,288 posns:0,0,0,4,4,4,4,4,4,4,4,4,7,7 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27],[22,20,-1,2,-2,2],[20] buf:
res_end       S:CharEscape+1 pos:7 " R:false stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284,285,20 posns:0,0,0,4,4,4,4,4,4,4,4,4,7 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27],[22,20,-1,2,-2,2] buf:20
result        S:CharEscape+1 pos:7 " R:false stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284,285,20 posns:0,0,0,4,4,4,4,4,4,4,4,4,7 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27],[22,20,-1,2,-2,2] buf:20
res_end       S:CharEscape+0 pos:7 " R:false stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284,285 posns:0,0,0,4,4,4,4,4,4,4,4,4,7 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27],[22,20,-1,2,-2,2] buf:20
result        S:CharEscape+0 pos:7 " R:false stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284,285 posns:0,0,0,4,4,4,4,4,4,4,4,4,7 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27],[22,20,-1,2,-2,2] buf:20
res_end       S:StrLit+4 pos:7 " R:false stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284 posns:0,0,0,4,4,4,4,4,4,4,4,4 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27] buf:22,20,-1,2,-2,2
result        S:StrLit+4 pos:7 " R:false stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284 posns:0,0,0,4,4,4,4,4,4,4,4,4 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27] buf:22,20,-1,2,-2,2

Again the first and last few trace lines are most relevant:

main          S:StrLit+4 pos:7 " R:undefined stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284 posns:0,0,0,4,4,4,4,4,4,4,4,4 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27] buf:22,20,-1,2,-2,2
main          S:CharEscape+0 pos:7 " R:undefined stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284,285 posns:0,0,0,4,4,4,4,4,4,4,4,4 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27] buf:22,20,-1,2,-2,2
 ...
res_end       S:CharEscape+0 pos:7 " R:false stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284,285 posns:0,0,0,4,4,4,4,4,4,4,4,4,7 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27],[22,20,-1,2,-2,2] buf:20
result        S:CharEscape+0 pos:7 " R:false stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284,285 posns:0,0,0,4,4,4,4,4,4,4,4,4,7 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27],[22,20,-1,2,-2,2] buf:20
res_end       S:StrLit+4 pos:7 " R:false stack:50,321,47,51,52,55,57,46,82,40,100,37,114,115,116,36,126,127,35,135,29,137,139,27,143,147,22,283,284 posns:0,0,0,4,4,4,4,4,4,4,4,4 bufs:[],[47],[],[46,44,39,-2,1,-2,1,41,42,-1,1,-2,1,-2,1,-1,1,41,42,-1,1,-2,1,-2,1],[40],[37],[],[],[36],[35],[29],[27] buf:22,20,-1,2,-2,2

Between the beginning and end of the CharEscape rule application:
The stack is unchanged.
The position stack is unchanged.
The buf stack and the current buf are unchanged, as is the current position.
So, no state is changed, except for the R variable which becomes false, indicating to the caller (the StrLit+4 expression) that the CharEscape rule did not match.


,dfa:{type:'transition'  // state 0
     ,transition:[[[92,93] => [2]
                  ,{type:'transition' // state 1
                   ,transition:[[[48,58,65,71] => [1]
                                ,{type:'transition' // state 2
                                 ,transition:[[[48,58,65,71]
                                              ,{type:'transition' // state 3
                                               ,transition:[[[48,58,65,71]
                                                            ,{type:'transition' // state 4
                                                             ,transition:[[[48,58,65,71]
                                                                          ,{type:'match'}]]}]]}]]}]
                               ,[[102,103,110,111,114,115,116,117,118,119] => [3]
                                ,{type:'match'}]]}]]}
{cset_92,93:{key:'cset_92,93',cset:[92,93],equivs:[2],id:0}
,cset_48,58,65,71:{key:'cset_48,58,65,71',cset:[48,58,65,71],equivs:[1],id:1}
,cset_102,103,110,111,114,115,116,117,118,119:{key:'cset_102,103,110,111,114,115,116,117,118,119'
                                              ,equivs:[3],id:2
                                              ,cset:[102,103,110,111,114,115,116
                                                    ,117,118,119]}}
[[[[2]  ]]  // state 0 transition to state 1 on equiv class 2
,[[[1]  ]   // state 1 transition to state 2 on equiv class 1
 ,[[3],5]]  //         match on equiv class 3
,[[[1]  ]]  // state 2 transition to state 3 on equiv class 1
,[[[1]  ]]  // state 3 transition to state 4 on equiv class 1
,[[[1],5]]] // state 4 match on equiv class 1
// the default for any transition is to move to the next state, otherwise the state to move to must be given
// the 'match state' is the state one past the end of the array

expand_dfa([[[[2]]],[[[1]],[[3],5]],[[[1]]],[[[1]]],[[[1],5]]])


T=[,20480,24576,,28672,10927,,6831,36864,14] 