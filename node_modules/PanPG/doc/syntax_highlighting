Notes on a syntax highlighter for ECMAScript based on a full parser.

inputs:
- an ECMAScript program,
- a mapping from parser rules to HTML (or XML) elements and attributes.

output:
- an HTML fragment

----------
An example
----------

input program: function empty(){return true}

parse tree:

["Program (0–29)"
,["FunctionDeclaration (0–29)"
 ,["FunctionTok (0–8)"]
 ,["S (8–9)"]
 ,["Identifier (9–14)"]
 ,["FunctionBody (17–28)"
  ,["Statement (17–28)"
   ,["ReturnStatement (17–28)"
    ,["ReturnTok (17–23)"]
    ,["SnoLB (23–24)"]
    ,["Expr (24–28)"
     ,["AssignmentExpr (24–28)"
      ,["ConditionalExpr (24–28)"
       ,["LogicalOrExpr (24–28)"
        ,["LogicalAndExpr (24–28)"
         ,["BitwiseOrExpr (24–28)"
          ,["BitwiseXOrExpr (24–28)"
           ,["BitwiseAndExpr (24–28)"
            ,["EqualityExpr (24–28)"
             ,["RelationalExpr (24–28)"
              ,["ShiftExpr (24–28)"
               ,["AdditiveExpr (24–28)"
                ,["MultiplicativeExpr (24–28)"
                 ,["UnaryExpr (24–28)"
                  ,["PostfixExpr (24–28)"
                   ,["LeftHandSideExpr (24–28)"
                    ,["NewExpr (24–28)"
                     ,["MemberExpr (24–28)"
                      ,["PrimaryExpr (24–28)"
                       ,["Literal (24–28)"
                        ,["BooleanLiteral (24–28)"]]]]]]]]]]]]]]]]]]]]]]]]]]

HTML mapping:

Program → <code> class=ECMAScript
FunctionDeclaration → <span> class=funcDef
FunctionTok → <span> class=structural
[FunctionDeclaration] D [Identifier] → <dfn> class=funcName
FunctionBody → <span> class=funcBody
ReturnTok → <span> class=structural  -- it would be nice to have some link from this back to the function, perhaps
 things like break, continue, and return statements can be color coded with the block from which they escape
 maybe even with a line going out from the statement horizontally to the border of the enclosing box
BooleanLiteral → <span> class=literal (or maybe "keyword" or "value" or ...?)

We will clearly want some kind of auto-elide function to clean up the parse tree as a first step, unless and until we write the parser in some different way so as not to generate the non-information-bearing parse nodes in the first place.

Then we can run a TMProg over the tree which annotates some nodes with element names and class or id values.
In the same TMProg, one rule can generate HTML for any node, by reading the element name and attribute values (if any) and then emitting markup.

Alternatively, we can return a structure that defines the tags to insert at given positions in the original input.
The original string itself would not be included in this output.
This could be done by a general rule which defines a tags attribute on every node.
The tags attribute is a set of (position, string) pairs which encode HTML tags to be inserted into the input stream at the given positions.
If the node has an HTML element name, the tags attribute includes it, with any defined HTML attributes, at the start position.
The tags attribute then includes the concatenation of the tags attributes of any child nodes in order.
Finally the tags attribute includes the closing tag if any, at the end position of the match.

The HTML is then generated by reading the tags attribute of the root node, and interleaving the provided tags at the indicated locations in the original text.

This means we need to define a tags attribute on every element, some of which may have element names, some of which may have class and other HTML attributes defined, and some of which may have none of these.
Currently TMProg does not support dealing with optional attributes in this way.
What we need is a selector which selects nodes that have a particular attribute defined.
Or a way to get attributes that may be missing, and deal with the missing attributes manually.
Or a way to set defaults for an attribute which will then be overwritten by a more specific rule.
Which I guess we actually have, assuming that TMProg rules are taken as being applied in the order specified.